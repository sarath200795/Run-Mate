<!DOCTYPE html>
<html>
<head>
    <title>Land Market - Capture Mode</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; background: #000; font-family: 'Segoe UI', sans-serif; height: 100vh; display: flex; flex-direction: column; }
        .header { background: #111; padding: 15px; border-bottom: 2px solid #C5A059; text-align: center; color: white; display:flex; justify-content:space-between; align-items:center; }
        .bank-display { color: #FFD700; font-weight: bold; font-size: 1.1rem; border: 1px solid #C5A059; padding: 5px 10px; border-radius: 4px; }
        #map { flex: 1; position: relative; background: #e0e0e0; }
        /* Crosshair */
        .crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; pointer-events: none; z-index: 10; opacity: 0.8; }
        /* Controls */
        .controls { padding: 15px; background: #111; border-top: 1px solid #333; text-align: center; }
        .btn-claim { background: #C5A059; color: black; border: none; padding: 15px 30px; font-weight: bold; font-family: 'Cinzel', serif; font-size: 1.1rem; border-radius: 4px; cursor: pointer; width: 100%; max-width: 300px; transition: background 0.3s; }
        .btn-claim.confirm { background: #d32f2f; color: white; animation: pulse 1.5s infinite; } /* Red for Attack/Confirm */
        .btn-back { background: none; border: 1px solid #555; color: #888; padding: 5px 10px; font-size: 0.8rem; cursor: pointer; border-radius: 4px; }
        /* Legend */
        .legend { position: absolute; bottom: 140px; left: 10px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 4px; font-size: 0.8rem; color: #ccc; pointer-events: none; z-index: 5; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .color-box { width: 15px; height: 15px; margin-right: 8px; border: 1px solid #fff; }
        
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(211, 47, 47, 0); } 100% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0); } }
    </style>
</head>
<body>
    <div class="header">
        <button class="btn-back" onclick="window.location.href='dashboard.html'">Back</button>
        <div class="bank-display">Banked: <span id="bankVal">0</span> m²</div>
        <div style="width:50px;"></div> 
    </div>

    <div id="map">
        <div class="legend">
            <div class="legend-item"><div class="color-box" style="background:#00e676; opacity:0.6;"></div>Your Land</div>
            <div class="legend-item"><div class="color-box" style="background:#2196F3; opacity:0.6;"></div>Ally (Clan)</div>
            <div class="legend-item"><div class="color-box" style="background:#F44336; opacity:0.6;"></div>Enemy</div>
            <div class="legend-item"><div class="color-box" style="background:#FFD700; opacity:0.6; border:1px dashed white;"></div>Target</div>
        </div>
        <svg class="crosshair" viewBox="0 0 100 100">
            <line x1="50" y1="0" x2="50" y2="100" stroke="#000" stroke-width="2" />
            <line x1="0" y1="50" x2="100" y2="50" stroke="#000" stroke-width="2" />
            <circle cx="50" cy="50" r="40" stroke="#000" stroke-width="2" fill="none" />
        </svg>
    </div>

    <div class="controls">
        <div style="color:#888; font-size:0.9rem; margin-bottom:10px;">Target Enemy lands to capture overlap.</div>
        <button class="btn-claim" id="btnClaim">PREVIEW TARGET</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, push, update, onValue, get } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

        const GOOGLE_API_KEY = "AIzaSyAzfoxuzRbmyrhGChfTEWB05xvyNRmvK3k"; 
        const firebaseConfig = { databaseURL: "https://runmate-cb328-default-rtdb.firebaseio.com/" };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const currentUser = localStorage.getItem('currentUser');

        if (!currentUser) window.location.href = 'index.html';

        let map, bankAmount = 0;
        let myClanId = null;
        let allPolygons = []; // Format: { id, owner, clan, turfPoly, googlePoly, rawCoords }
        let previewPolygon = null; 
        let previewCoords = null;  
        let isPreviewMode = false; 

        window.initMap = function() {
            const mapEl = document.getElementById("map");
            try {
                map = new google.maps.Map(mapEl, {
                    zoom: 18, center: { lat: 0, lng: 0 }, mapTypeId: 'roadmap', disableDefaultUI: true,
                    styles: [{ featureType: "poi", elementType: "labels", stylers: [{ visibility: "off" }] }]
                });

                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(pos => {
                        map.setCenter({ lat: pos.coords.latitude, lng: pos.coords.longitude });
                    });
                } else { map.setCenter({ lat: 40.7128, lng: -74.0060 }); }

                map.addListener('center_changed', () => {
                    if (isPreviewMode) resetPreview();
                });

                loadUserData(); 
                loadExistingLands();
            } catch (err) { console.error("Map Error:", err); }
        };

        function loadGoogleMaps() {
            if (document.getElementById('google-maps-script')) return; 
            const script = document.createElement('script');
            script.id = 'google-maps-script';
            script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry&callback=initMap`;
            script.async = true; script.defer = true;
            document.head.appendChild(script);
        }

        function loadUserData() {
            onValue(ref(db, `users/${currentUser}`), (snap) => {
                const val = snap.val();
                if(val) {
                    bankAmount = val.bankedArea || 0;
                    myClanId = val.clanId || null; // Capture user's clan
                }
                document.getElementById('bankVal').innerText = Math.round(bankAmount);
                checkButtonState();
            });
        }

        function checkButtonState() {
            const btn = document.getElementById('btnClaim');
            if (bankAmount < 5) {
                btn.disabled = true; 
                btn.style.background = "#333"; 
                btn.innerText = "Insufficient Banked Area";
                btn.classList.remove('confirm');
            } else if (!isPreviewMode) {
                btn.disabled = false; 
                btn.style.background = "#C5A059"; 
                btn.innerText = "PREVIEW TARGET";
                btn.classList.remove('confirm');
            }
        }

        function resetPreview() {
            if (previewPolygon) {
                previewPolygon.setMap(null);
                previewPolygon = null;
            }
            previewCoords = null;
            isPreviewMode = false;
            
            const btn = document.getElementById('btnClaim');
            btn.innerText = "PREVIEW TARGET";
            btn.style.background = "#C5A059";
            btn.classList.remove('confirm');
        }

        // --- LOAD LANDS WITH OWNER INFO ---
        function loadExistingLands() {
            onValue(ref(db, 'territories'), (snapshot) => {
                const data = snapshot.val();
                
                // Cleanup old map objects
                if(allPolygons.length > 0) { 
                    allPolygons.forEach(p => p.googlePoly.setMap(null)); 
                    allPolygons = []; 
                }

                if (data) {
                    Object.entries(data).forEach(([key, t]) => {
                        // Determine Color based on Relationship
                        let fillC, strokeC;
                        const isMine = t.owner === currentUser;
                        const isAlly = !isMine && myClanId && t.clanId === myClanId; // Check clan

                        if (isMine) { fillC = '#00e676'; strokeC = '#004d26'; }
                        else if (isAlly) { fillC = '#2196F3'; strokeC = '#0D47A1'; } // Ally Blue
                        else { fillC = '#F44336'; strokeC = '#B71C1C'; } // Enemy Red

                        const zIdx = isMine ? 10 : 1;
                        
                        // Create Visual Polygon
                        const poly = new google.maps.Polygon({
                            paths: t.coords, fillColor: fillC, fillOpacity: 0.5, strokeColor: strokeC, strokeWeight: 2, zIndex: zIdx, map: map, clickable: false 
                        });

                        // Create Turf Polygon for Math
                        // Ensure closed loop
                        const tCoords = t.coords.map(c => [c.lng, c.lat]);
                        if (tCoords.length > 0 && (tCoords[0][0] !== tCoords[tCoords.length-1][0] || tCoords[0][1] !== tCoords[tCoords.length-1][1])) {
                            tCoords.push(tCoords[0]);
                        }
                        
                        let turfPoly = turf.polygon([tCoords]);
                        // Fix Winding direction for accurate math
                        turfPoly = turf.rewind(turfPoly);

                        allPolygons.push({ 
                            id: key, 
                            owner: t.owner, 
                            clan: t.clanId || null,
                            turfPoly: turfPoly, 
                            googlePoly: poly,
                            rawCoords: t.coords
                        });
                    });
                }
            });
        }

        // --- MAIN BUTTON LOGIC ---
        document.getElementById('btnClaim').addEventListener('click', async () => {
            if(bankAmount < 5) return;
            const btn = document.getElementById('btnClaim');

            // --- STEP 1: PREVIEW (VALIDATION) ---
            if (!isPreviewMode) {
                const center = map.getCenter();
                const radiusMeters = Math.sqrt(bankAmount / Math.PI);
                
                // 1. Generate Circle
                previewCoords = generateCircleCoords(center.lat(), center.lng(), radiusMeters);
                
                // 2. Convert to Turf for Checking
                const turfCoords = previewCoords.map(c => [c.lng, c.lat]);
                turfCoords.push([previewCoords[0].lng, previewCoords[0].lat]); 
                const newPoly = turf.polygon([turfCoords]);

                // 3. CHECK OVERLAPS
                let touchesEnemy = false;

                for(const existing of allPolygons) {
                    if (turf.booleanIntersects(newPoly, existing.turfPoly)) { 
                        
                        // FAIL: Touching Self
                        if (existing.owner === currentUser) {
                            alert("⚠️ Blocked! You cannot overlap your own land."); 
                            return; 
                        }
                        // FAIL: Touching Ally (Clan)
                        if (myClanId && existing.clan === myClanId) {
                            alert("⚠️ Blocked! You cannot steal land from your Clan Ally."); 
                            return;
                        }

                        // ALLOW: Touching Enemy
                        touchesEnemy = true;
                    }
                }

                // 4. Draw Preview
                previewPolygon = new google.maps.Polygon({
                    paths: previewCoords,
                    fillColor: "#FFD700",
                    fillOpacity: 0.4,
                    strokeColor: "#FFD700",
                    strokeWeight: 2,
                    map: map,
                    clickable: false
                });

                // 5. Update UI
                isPreviewMode = true;
                if(touchesEnemy) {
                    btn.innerText = "ATTACK & CLAIM"; // Change text for aggression
                } else {
                    btn.innerText = "CONFIRM CLAIM";
                }
                btn.classList.add('confirm');
                return;
            }

            // --- STEP 2: EXECUTION (CALCULATION & DB UPDATE) ---
            if (isPreviewMode && previewCoords) {
                if(!confirm(`Finalize capture of ${Math.round(bankAmount)} m²?`)) return;

                const updates = {};
                
                // A. CREATE MY NEW LAND
                const newKey = push(ref(db, 'territories')).key;
                
                // Prepare turf poly of my new shape for math
                const myTurfCoords = previewCoords.map(c => [c.lng, c.lat]);
                myTurfCoords.push(myTurfCoords[0]);
                const myTurfPoly = turf.polygon([myTurfCoords]);

                updates[`territories/${newKey}`] = { 
                    owner: currentUser, 
                    clanId: myClanId || null,
                    coords: previewCoords, 
                    areaSize: bankAmount, 
                    timestamp: Date.now(), 
                    source: 'Market' 
                };

                // B. DEDUCT POINTS/BANK
                updates[`users/${currentUser}/bankedArea`] = 0; 

                // C. PROCESS ENEMY CUTS
                let enemiesHit = 0;

                allPolygons.forEach(target => {
                    // Check intersection again to be safe
                    if (turf.booleanIntersects(myTurfPoly, target.turfPoly)) {
                        
                        // Calculate Difference: Enemy - MyNewShape
                        const diff = turf.difference(target.turfPoly, myTurfPoly);

                        if (!diff) {
                            // Result is null/undefined = Fully Consumed
                            updates[`territories/${target.id}`] = null; // DELETE
                            enemiesHit++;
                        } else {
                            // Result exists = Partial Cut
                            // Turf might return Polygon or MultiPolygon. 
                            // For simplicity, we convert the geometry back to Google Maps format.
                            const geometryType = diff.geometry.type;
                            
                            if (geometryType === 'Polygon') {
                                const newCoords = diff.geometry.coordinates[0].map(pt => ({ lat: pt[1], lng: pt[0] }));
                                // Remove closing point for Google Maps cleanliness (optional but good)
                                newCoords.pop(); 
                                updates[`territories/${target.id}/coords`] = newCoords;
                                enemiesHit++;
                            } else if (geometryType === 'MultiPolygon') {
                                // Logic: Enemy split into islands. 
                                // Simple Handling: Keep the largest island, lose the small fragments (or create new nodes).
                                // For this prototype, we take the first/largest piece.
                                const newCoords = diff.geometry.coordinates[0][0].map(pt => ({ lat: pt[1], lng: pt[0] }));
                                newCoords.pop();
                                updates[`territories/${target.id}/coords`] = newCoords;
                                enemiesHit++;
                            }
                        }
                    }
                });

                // Bonus Points if attacking
                const userSnap = await get(ref(db, `users/${currentUser}`));
                const currentPoints = userSnap.val().creditPoints || 0;
                updates[`users/${currentUser}/creditPoints`] = currentPoints + 10 + (enemiesHit * 50);

                try { 
                    await update(ref(db), updates); 
                    resetPreview(); 
                    alert(enemiesHit > 0 ? "⚔️ Victory! Enemy territory captured." : "Territory Claimed Successfully!"); 
                    window.location.href = 'dashboard.html'; 
                } catch(e) { 
                    alert("Error: " + e.message); 
                }
            }
        });

        function generateCircleCoords(lat, lng, radius) {
            const points = 32; const coords = [];
            for (let i = 0; i < points; i++) {
                const theta = (i / points) * (2 * Math.PI);
                const offset = google.maps.geometry.spherical.computeOffset(new google.maps.LatLng(lat, lng), radius, (theta * 180) / Math.PI);
                coords.push({ lat: offset.lat(), lng: offset.lng() });
            }
            return coords;
        }

        loadGoogleMaps();
    </script>
</body>
</html>
