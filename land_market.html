<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Land Market</title>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #e0e0e0; padding: 20px; }
        h2 { margin-top: 0; color: #333; }
        
        .layout { display: flex; gap: 20px; align-items: flex-start; }
        
        .map-container {
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background: white;
            border: 2px solid #555;
            cursor: crosshair;
        }

        .sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .legend {
            background: white; 
            padding: 15px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; }
        .color-box { width: 16px; height: 16px; margin-right: 10px; border: 1px solid #333; }

        .logs {
            background: #fff;
            height: 300px;
            overflow-y: auto;
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #ccc;
            font-family: monospace;
            font-size: 13px;
        }
        .log-msg { margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 2px; }
        .error { color: #d32f2f; font-weight: bold; }
        .success { color: #388e3c; font-weight: bold; }
        
        button {
            padding: 10px; cursor: pointer; background: #333; color: white; border: none; border-radius: 4px; font-size: 14px;
        }
        button:hover { background: #555; }
    </style>
</head>
<body>

    <div class="layout">
        <div>
            <h2>Land Market</h2>
            <div class="map-container">
                <canvas id="marketCanvas" width="800" height="600"></canvas>
            </div>
            <p style="color:#666; font-size: 14px;">* Click and Drag deeply over Enemy lands to capture.</p>
        </div>

        <div class="sidebar">
            <div class="legend">
                <h4>Territory Legend</h4>
                <div class="legend-item"><div class="color-box" style="background:#2196F3"></div> User (Self)</div>
                <div class="legend-item"><div class="color-box" style="background:#4CAF50"></div> Clan Mate (Ally)</div>
                <div class="legend-item"><div class="color-box" style="background:#F44336"></div> Enemy (Target)</div>
            </div>
            
            <button onclick="resetMarket()">Reset Market Map</button>
            
            <div id="consoleLogs" class="logs">
                <div class="log-msg">System initialized...</div>
            </div>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const canvas = document.getElementById('marketCanvas');
    const ctx = canvas.getContext('2d');
    const logContainer = document.getElementById('consoleLogs');

    // Identifiers
    const USER_ID = 'me';
    const CLAN_ID = 'my_clan';

    // State
    let allLands = [];
    let isSelecting = false;
    let startPos = { x: 0, y: 0 };
    let currentMouse = { x: 0, y: 0 };

    // --- INITIALIZATION ---
    window.onload = function() {
        if (typeof turf === 'undefined') {
            log("ERROR: Turf.js library failed to load. Please check internet connection.", "error");
            return;
        }
        initMapData();
    };

    function initMapData() {
        allLands = [];

        // Note: We use turf.rewind to ensure all polygons are Counter-Clockwise (CCW)
        // This fixes the "invisible map" issue.
        
        // 1. User Land (Blue)
        addLand(USER_ID, CLAN_ID, '#2196F3', [[50, 50], [50, 150], [200, 150], [200, 50], [50, 50]]);

        // 2. Clan Mate Land (Green)
        addLand('friend_1', CLAN_ID, '#4CAF50', [[250, 50], [250, 150], [400, 150], [400, 50], [250, 50]]);

        // 3. Enemy Land A (Red Square)
        addLand('enemy_A', 'bad_clan', '#F44336', [[100, 300], [100, 500], [300, 500], [300, 300], [100, 300]]);

        // 4. Enemy Land B (Red Rectangle)
        addLand('enemy_B', 'bad_clan', '#F44336', [[350, 300], [350, 400], [550, 400], [550, 300], [350, 300]]);

        log("Map loaded. 4 Territories found.");
        render();
    }

    function addLand(owner, clan, color, coordinates) {
        // Create polygon
        let poly = turf.polygon([coordinates]);
        
        // CRITICAL FIX: Rewind ensures the math works correctly
        poly = turf.rewind(poly, {reverse: false}); // false ensures GeoJSON standard (CCW)

        allLands.push({
            id: Math.random().toString(36).substr(2, 5),
            owner: owner,
            clan: clan,
            color: color,
            geometry: poly
        });
    }

    // --- MOUSE INPUTS ---
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        startPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        isSelecting = true;
    });

    canvas.addEventListener('mousemove', e => {
        if (!isSelecting) return;
        const rect = canvas.getBoundingClientRect();
        currentMouse = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        render(); // Re-draw to show selection box
    });

    canvas.addEventListener('mouseup', e => {
        if (!isSelecting) return;
        isSelecting = false;
        
        const rect = canvas.getBoundingClientRect();
        const endX = e.clientX - rect.left;
        const endY = e.clientY - rect.top;

        // Ensure we have a valid box (width/height > 0)
        const x1 = Math.min(startPos.x, endX);
        const y1 = Math.min(startPos.y, endY);
        const x2 = Math.max(startPos.x, endX);
        const y2 = Math.max(startPos.y, endY);

        if (x2 - x1 < 5 || y2 - y1 < 5) return; // Ignore accidental clicks

        // Convert box to Polygon
        const boxCoords = [[x1, y1], [x2, y1], [x2, y2], [x1, y2], [x1, y1]];
        const selectionPoly = turf.polygon([boxCoords]);

        handleCapture(selectionPoly);
    });

    // --- GAME LOGIC ---
    function handleCapture(selectionPoly) {
        let landsToRemove = [];
        let landsToAdd = [];
        let errorFound = false;

        // 1. Validation Phase
        for (let land of allLands) {
            // Check if selection touches this land
            if (turf.booleanIntersects(selectionPoly, land.geometry)) {
                
                // Rule: Cannot capture Self
                if (land.owner === USER_ID) {
                    log("BLOCKED: Cannot capture your own land!", "error");
                    errorFound = true;
                    break;
                }
                // Rule: Cannot capture Clan Mate
                if (land.clan === CLAN_ID) {
                    log("BLOCKED: Cannot capture Clan Mate's land!", "error");
                    errorFound = true;
                    break;
                }
            }
        }

        if (errorFound) {
            render(); // Clear selection box
            return; 
        }

        // 2. Calculation Phase
        let capturedCount = 0;

        // We map through lands to see what changes
        for (let i = 0; i < allLands.length; i++) {
            let land = allLands[i];
            
            // Only process enemies or others
            if (!turf.booleanIntersects(selectionPoly, land.geometry)) {
                continue; // Skip lands we didn't touch
            }

            // A. Calculate CAPTURED part (Intersection)
            const captureGeo = turf.intersect(land.geometry, selectionPoly);
            
            if (captureGeo) {
                capturedCount++;
                // Add new piece for User
                landsToAdd.push({
                    id: 'new_' + Math.random().toString(36).substr(2, 4),
                    owner: USER_ID,
                    clan: CLAN_ID,
                    color: '#2196F3', // Turns Blue
                    geometry: captureGeo
                });
            }

            // B. Calculate REMAINING part (Difference)
            const remainingGeo = turf.difference(land.geometry, selectionPoly);

            // Mark old land for removal
            landsToRemove.push(land.id);

            // If there is land left, add it back as modified enemy land
            if (remainingGeo) {
                landsToAdd.push({
                    id: land.id, // Keep ID
                    owner: land.owner,
                    clan: land.clan,
                    color: land.color, // Stays Red
                    geometry: remainingGeo
                });
            } else {
                log(`Enemy land ${land.id} was fully destroyed.`);
            }
        }

        if (capturedCount > 0) {
            // Commit changes
            allLands = allLands.filter(l => !landsToRemove.includes(l.id)); // Remove old
            allLands = allLands.concat(landsToAdd); // Add new
            log(`Success! Captured territory from ${capturedCount} location(s).`, "success");
        } else {
            log("No enemy land selected.");
        }

        render();
    }

    // --- RENDERING SYSTEM ---
    function render() {
        // Clear screen
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Lands
        allLands.forEach(land => {
            ctx.fillStyle = land.color;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

            // Handle MultiPolygons (if land got split into islands)
            const type = land.geometry.geometry.type;
            const coords = land.geometry.geometry.coordinates;

            if (type === 'Polygon') {
                drawPolygon(coords);
            } else if (type === 'MultiPolygon') {
                coords.forEach(polyCoords => drawPolygon(polyCoords));
            }
        });

        // Draw Selection Box (if dragging)
        if (isSelecting) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.strokeStyle = '#333';
            ctx.setLineDash([5, 5]);
            
            const w = currentMouse.x - startPos.x;
            const h = currentMouse.y - startPos.y;
            
            ctx.fillRect(startPos.x, startPos.y, w, h);
            ctx.strokeRect(startPos.x, startPos.y, w, h);
            
            ctx.setLineDash([]);
        }
    }

    function drawPolygon(rings) {
        // rings[0] is the outer boundary
        const outer = rings[0];
        ctx.beginPath();
        if(outer.length > 0) {
            ctx.moveTo(outer[0][0], outer[0][1]);
            for (let i = 1; i < outer.length; i++) {
                ctx.lineTo(outer[i][0], outer[i][1]);
            }
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // (Optional: Inner rings/holes would be handled here in a full engine)
    }

    // --- UTILITIES ---
    function log(msg, type) {
        const line = document.createElement('div');
        line.className = 'log-msg ' + (type || '');
        line.innerText = `> ${msg}`;
        logContainer.insertBefore(line, logContainer.firstChild);
    }

    function resetMarket() {
        logContainer.innerHTML = '';
        log("Resetting map...");
        initMapData();
    }

</script>
</body>
</html>
