<!DOCTYPE html>
<html>
<head>
    <title>Conquest Map</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html, body { height: 100%; margin: 0; padding: 0; background: #000; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        #map { height: 100%; width: 100%; }
        
        /* INDOOR INTERFACE STYLES */
        #indoorInterface {
            display: none; height: 100%; width: 100%;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            flex-direction: column; align-items: center; justify-content: center;
            color: white; position: absolute; top: 0; left: 0; z-index: 50;
        }
        .metric-circle {
            width: 200px; height: 200px; border-radius: 50%; border: 5px solid #00e676;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            margin-bottom: 30px; box-shadow: 0 0 30px rgba(0, 230, 118, 0.2);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 10px rgba(0,230,118,0.1); } 50% { box-shadow: 0 0 30px rgba(0,230,118,0.4); } 100% { box-shadow: 0 0 10px rgba(0,230,118,0.1); } }
        
        .metric-val { font-size: 2.5rem; font-weight: bold; color: white; font-family: 'Cinzel', serif; }
        .metric-label { color: #888; font-size: 0.9rem; margin-top: 5px; text-transform: uppercase; }
        .bank-box { background: #222; padding: 15px 30px; border-radius: 8px; border: 1px solid #FFD700; text-align: center; }

        .sidebar { position: absolute; top: 0; left: 0; bottom: 0; width: 250px; background: rgba(20,20,20,0.95); border-right: 2px solid #8B0000; z-index: 400; transform: translateX(-100%); transition: 0.3s; color: white; padding-top: 10px; display:flex; flex-direction:column;}
        .sidebar.open { transform: translateX(0); }
        .menu-toggle { position: absolute; top: 10px; left: 10px; z-index: 401; background: #8B0000; color: white; padding: 8px 12px; border-radius: 4px; font-weight: bold; cursor: pointer; border: 2px solid #ff4444; font-family: 'Cinzel', serif; }
        .sb-header { text-align: center; padding: 10px; border-bottom: 1px solid #444; }
        .rank-badge { background: linear-gradient(135deg, #FFD700, #B8860B); color: black; padding: 5px; border-radius: 4px; font-weight: bold; display: inline-block; font-family: 'Cinzel', serif; margin-top:5px;}
        .sb-stats { padding: 20px; text-align: center; }
        .sb-val { font-size: 1.4rem; color: #00e676; font-weight: bold; }
        .sb-sub { color:#aaa; font-size:0.8rem; margin-bottom: 15px; }
        .points-box { background: #111; border: 1px solid #C5A059; padding: 10px; margin: 10px; border-radius: 6px; }
        .points-val { color: #C5A059; font-size: 1.2rem; font-weight: bold; }
        
        .controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; z-index: 300; display: flex; flex-direction: column; gap: 10px; }
        button { padding: 15px; border: none; border-radius: 12px; font-size: 1.1rem; font-weight: bold; cursor: pointer; font-family: 'Cinzel', serif; text-transform: uppercase; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        #startBtn { background: linear-gradient(180deg, #00e676, #00c853); color: #003300; }
        
        #stopBtn { background: linear-gradient(180deg, #ff1744, #d50000); color: white; display: none; transition: 0.3s; }
        #stopBtn.ready { background: linear-gradient(180deg, #FFD700, #B8860B); color: black; animation: pulse 2s infinite; border: 2px solid #fff; }

        .toast { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 15px 25px; border-radius: 50px; color: white; font-weight: bold; border: 2px solid #ff4444; display: none; z-index: 500; text-align: center; white-space: nowrap; box-shadow: 0 0 20px rgba(255, 0, 0, 0.4); }
        .sb-clan { flex: 1; padding: 10px; overflow-y: auto; border-top: 1px solid #444; }
        .lb-item { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid #333; font-size: 0.85rem; }
        .logout-btn-sb { padding: 10px; border: 1px solid #ff4444; color: #ff4444; background: none; margin: 10px; cursor: pointer; }
        
        .mode-switch-container { position: absolute; top: 10px; right: 10px; z-index: 401; background: rgba(0,0,0,0.8); padding: 5px; border-radius: 20px; border: 1px solid #C5A059; display: flex; gap: 5px; }
        .mode-btn { padding: 8px 15px; border-radius: 15px; border: none; cursor: pointer; font-weight: bold; color: #aaa; background: none; font-size: 0.8rem; }
        .mode-btn.active { background: #C5A059; color: black; }

        .modal { display: none; position: fixed; z-index: 999; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); align-items: center; justify-content: center; }
        .modal-content { background: #1a1a1a; padding: 25px; border: 2px solid #C5A059; border-radius: 8px; width: 90%; max-width: 400px; color: white; text-align: center; position: relative; }
        .modal h2 { color: #C5A059; margin-top: 0; font-family: 'Cinzel', serif; }
        .modal-stat { display: flex; justify-content: space-between; margin: 10px 0; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .range-wrap { margin: 20px 0; }
        input[type=range] { width: 100%; }
        .btn-confirm { background: #00e676; color: black; border: none; padding: 12px; width: 100%; font-weight: bold; cursor: pointer; border-radius: 4px; margin-top: 10px; font-size: 1.1rem; }
        .btn-cancel { background: none; border: 1px solid #444; color: #888; padding: 10px; width: 100%; margin-top: 10px; cursor: pointer; border-radius: 4px; }
        .helper-text { font-size: 0.8rem; color: #888; margin-bottom: 15px; white-space: pre-line; }
    </style>
</head>
<body>
    <div class="menu-toggle" id="menuBtn">‚ò∞ STATS</div>
    
    <div class="mode-switch-container">
        <button class="mode-btn active" id="btnModeOut" onclick="window.setMode('outdoor')">üèπ OUTDOOR</button>
        <button class="mode-btn" id="btnModeIn" onclick="window.setMode('indoor')">üèÉ INDOOR</button>
    </div>

    <div id="indoorInterface">
        <h2 style="color:#C5A059; font-family:'Cinzel', serif; letter-spacing:2px; margin-bottom:30px;">TRAINING MODE</h2>
        <div class="metric-circle"><div class="metric-val" id="indDistLarge">0</div><div class="metric-label">METERS</div></div>
        <div class="bank-box"><div class="metric-label">BANKABLE AREA</div><div class="metric-val" style="font-size:1.8rem; color:#FFD700;" id="indAreaLarge">0 m¬≤</div></div>
        <div style="color:#666; font-size:0.8rem; margin-top:30px; max-width:250px; text-align:center;">Keep walking to accumulate area. Stop to bank it for the Market.</div>
    </div>

    <div id="toast" class="toast">‚ö†Ô∏è WARNING</div>

    <div class="sidebar" id="sidebar">
        <div class="sb-header"><div id="sbUser">...</div><div id="sbRank" class="rank-badge">Peasant</div></div>
        <div class="sb-stats">
            <div><div class="sb-val" id="sbArea">0 m¬≤</div><div class="sb-sub">TOTAL AREA</div></div>
            <div class="points-box">
                <div>CREDIT POINTS</div>
                <div class="points-val" id="sbPoints">0</div>
                <div style="font-size:0.8rem; color:#888;">Streak: <span id="sbStreak" style="color:white;">0</span> Days</div>
            </div>
        </div>
        <div class="sb-clan" id="clanSection" style="display:none;"><div style="color:#C5A059; text-align:center; font-family:'Cinzel', serif;">CLAN RANKING</div><div id="clanLeaderboard"></div></div>
        <button class="logout-btn-sb" onclick="window.logout()">LOGOUT</button>
    </div>

    <div id="map"></div>
    
    <div class="controls">
        <div id="modeHelper" style="background:rgba(0,0,0,0.7); padding:10px; border-radius:8px; margin-bottom:10px; text-align:center; color:#ccc; font-size:0.9rem;">üí° Tap Green/Gold territories to deploy guards</div>
        <button id="startBtn">‚öîÔ∏è Start Conquest</button>
        <button id="stopBtn">üö© Claim Territory</button>
        <a href="dashboard.html" style="background:white; text-align:center; padding:10px; border-radius:8px; font-weight:bold; color:black; text-decoration:none; font-family:'Cinzel', serif;">Exit to Command</a>
    </div>

    <div id="guardModal" class="modal">
        <div class="modal-content">
            <h2 id="mTitle">üõ°Ô∏è Secure Territory</h2>
            <div id="mHelper" class="helper-text">...</div>
            <div class="modal-stat"><span>Territory Area:</span><span id="mArea">...</span></div>
            <div class="modal-stat"><span>Guards Needed:</span><span id="mReq" style="color:#FFD700">...</span></div>
            <div class="range-wrap"><label>Deploy Count: <span id="mCountVal" style="font-weight:bold; font-size:1.2rem; color:#00e676;">1</span></label><input type="range" id="mRange" min="1" max="1" value="1" step="1"></div>
            <div style="background:#222; padding:10px; border-radius:4px; margin-bottom:10px;">
                <div style="display:flex; justify-content:space-between;"><span>Total Cost:</span><span id="mCost" style="color:#ff4444; font-weight:bold;">10 Pts</span></div>
                <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#888;"><span>Duration:</span><span>7 Days</span></div>
            </div>
            <button id="btnConfirm" class="btn-confirm">DEPLOY GUARDS</button>
            <button class="btn-cancel" onclick="document.getElementById('guardModal').style.display='none'">Cancel</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, push, update, onValue, get, child, runTransaction } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

        // --- API KEY ---
        const GOOGLE_API_KEY = "AIzaSyAzfoxuzRbmyrhGChfTEWB05xvyNRmvK3k"; 

        const firebaseConfig = { databaseURL: "https://runmate-cb328-default-rtdb.firebaseio.com/" };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        
        let map, userMarker, activePolyline, watchId, pathCoords = [];
        let allPolygons = []; 
        let visualPolygons = []; 
        let lastKnownPos = null;
        let gameMode = 'outdoor'; 
        let indoorDistance = 0;
        let lastIndoorPos = null;
        
        const currentUser = localStorage.getItem('currentUser');
        const userIcon = localStorage.getItem('userIcon') || "üë§";
        let myClan = null;
        let myClanMembers = {};
        let currentStreak = 0;
        let totalPoints = 0;
        let bankedArea = 0;
        let lastConquestDate = 0;
        let selectedLandId = null;

        if(!currentUser) window.location.href = 'index.html';
        document.getElementById('sbUser').innerText = `${userIcon} ${currentUser}`;
        document.getElementById('menuBtn').addEventListener('click', () => document.getElementById('sidebar').classList.toggle('open'));

        window.logout = function() { if(confirm("Logout?")) { localStorage.clear(); window.location.href = 'index.html'; }};
        
        // --- IMPORTANT: GLOBAL MAP INIT FUNCTION ---
        window.initMap = function() {
            console.log("Map initialized called.");
            const mapEl = document.getElementById("map");
            if (!mapEl) return;

            map = new google.maps.Map(mapEl, {
                zoom: 19, center: { lat: 0, lng: 0 }, mapTypeId: 'terrain', disableDefaultUI: true,
                styles: [{ elementType: "geometry", stylers: [{ color: "#242f3e" }] }, { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] }, { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] }, { featureType: "road", elementType: "geometry", stylers: [{ color: "#38414e" }] }]
            });
            loadUserData();
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(pos => {
                    const latLng = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                    lastKnownPos = latLng;
                    updateUserMarker(latLng);
                    if(gameMode === 'outdoor') checkGuardProximity(latLng);
                }, err => console.error(err), { enableHighAccuracy: true });
            }
        };

        // --- ROBUST LOADER ---
        function loadGoogleMaps() {
            if (window.google && window.google.maps) {
                // If map API is already loaded (from cache or previous page), just init
                window.initMap();
            } else if (!document.getElementById('google-maps-script')) {
                // Otherwise inject script
                const script = document.createElement('script');
                script.id = 'google-maps-script';
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry&callback=initMap`;
                script.async = true;
                script.defer = true;
                document.head.appendChild(script);
            }
        }

        window.setMode = (mode) => {
            if(document.getElementById('stopBtn').style.display === 'block') return alert("Stop current session first!");
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            
            const mapDiv = document.getElementById('map');
            const indDiv = document.getElementById('indoorInterface');

            if(mode === 'outdoor') {
                document.getElementById('btnModeOut').classList.add('active');
                mapDiv.style.display = 'block';
                indDiv.style.display = 'none';
                document.getElementById('modeHelper').innerText = "üí° Tap Green/Gold territories to deploy guards";
                document.getElementById('startBtn').innerText = "‚öîÔ∏è Start Conquest";
                document.getElementById('stopBtn').innerText = "üö© Claim Territory";
                if(map) google.maps.event.trigger(map, "resize");
            } else {
                document.getElementById('btnModeIn').classList.add('active');
                mapDiv.style.display = 'none';
                indDiv.style.display = 'flex';
                document.getElementById('modeHelper').innerText = "üèÉ Walk to bank area. Redeem later in Market.";
                document.getElementById('startBtn').innerText = "üèÉ Start Training";
                document.getElementById('stopBtn').innerText = "üíæ Bank Area";
            }
        };

        function showToast(msg, isBad=false) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.display = 'block';
            t.style.borderColor = isBad ? '#ff1744' : '#00e676';
            t.style.color = isBad ? '#ff8a80' : '#b9f6ca';
            setTimeout(() => { t.style.display = 'none'; }, 3000);
        }

        function calculateRank(area) {
            if (area >= 100000) return "üëë KING";
            if (area >= 10000) return "‚öîÔ∏è WARRIOR";
            if (area >= 1000) return "üõ°Ô∏è SOLDIER";
            if (area >= 100) return "üåæ FARMER";
            return "ü™µ PEASANT";
        }

        function updateUserMarker(pos) {
            if (!userMarker) {
                userMarker = new google.maps.Marker({ position: pos, map: map, label: { text: userIcon, fontSize: "24px", color: "white" }, title: currentUser });
                map.setCenter(pos);
            } else { userMarker.setPosition(pos); }
        }

        function checkGuardProximity(pos) {
            if(!allPolygons.length || !pos) return;
            const pt = turf.point([pos.lng, pos.lat]);
            for(const pData of allPolygons) {
                if (turf.booleanPointInPolygon(pt, pData.polygon)) {
                    const t = pData.data;
                    if (t.guarded && t.owner !== currentUser) {
                         if(!t.guardExpiry || t.guardExpiry > Date.now()) { showToast("‚õî GUARD DETECTED! AREA SECURED", true); }
                    }
                    return; 
                }
            }
        }

        function loadUserData() {
            onValue(ref(db, `users/${currentUser}`), (snap) => {
                const u = snap.val();
                if(!u) return;
                myClan = u.clan || null;
                currentStreak = u.streak || 0;
                totalPoints = u.creditPoints || 0;
                bankedArea = u.bankedArea || 0;
                lastConquestDate = u.lastActiveDate || 0;
                document.getElementById('sbPoints').innerText = totalPoints;
                document.getElementById('sbStreak').innerText = currentStreak;
                
                if(myClan) { 
                    document.getElementById('clanSection').style.display = 'block'; 
                    get(child(ref(db), `clans/${myClan}/members`)).then(mSnap => { 
                        myClanMembers = mSnap.val() || {}; loadTerritories(); 
                    });
                } else {
                    myClanMembers = {}; loadTerritories();
                }
            });
        }

        function loadStatsAndRank(data) {
            let myArea = 0, clanStats = {};
            Object.values(data).forEach(t => {
                if (t.owner === currentUser) { myArea += (t.areaSize||0); }
                if (myClan) { if (!clanStats[t.owner]) clanStats[t.owner] = 0; clanStats[t.owner] += (t.areaSize||0); }
            });
            document.getElementById('sbArea').innerText = Math.round(myArea).toLocaleString() + " m¬≤";
            document.getElementById('sbRank').innerText = calculateRank(myArea);
            if (myClan) updateClanLeaderboard(clanStats);
        }

        async function updateClanLeaderboard(rawStats) {
            const clanSnap = await get(child(ref(db), `clans/${myClan}/members`));
            const members = clanSnap.val() || {};
            let lb = [];
            Object.keys(members).forEach(uid => lb.push({ name: uid, score: rawStats[uid] || 0 }));
            lb.sort((a, b) => b.score - a.score);
            document.getElementById('clanLeaderboard').innerHTML = lb.slice(0, 10).map((p, i) => `<div class="lb-item"><span>#${i+1} ${p.name}</span><span style="color:#aaa;">${Math.round(p.score)}</span></div>`).join('');
        }

        const rangeInput = document.getElementById('mRange');
        rangeInput.addEventListener('input', (e) => updateModalCalc(e.target.value));

        function updateModalCalc(val) {
            document.getElementById('mCountVal').innerText = val;
            const cost = val * 10;
            const costEl = document.getElementById('mCost');
            costEl.innerText = cost + " Pts";
            const btn = document.getElementById('btnConfirm');
            if (totalPoints < cost) {
                costEl.style.color = "red"; btn.disabled = true; btn.innerText = "NOT ENOUGH POINTS"; btn.style.background = "#444";
            } else {
                costEl.style.color = "#ff4444"; btn.disabled = false; btn.innerText = "DEPLOY GUARDS"; btn.style.background = "#00e676";
            }
        }

        window.openDeploymentModal = (landId, area, isAlly = false) => {
            selectedLandId = landId;
            const coverage = isAlly ? 250 : 500; 
            const requiredGuards = Math.ceil(area / coverage);
            document.getElementById('mTitle').innerText = isAlly ? "üõ°Ô∏è Reinforce Ally" : "üõ°Ô∏è Secure Territory";
            document.getElementById('mHelper').innerText = isAlly ? "Ally Territory (Reduced Efficiency)" : "Personal Territory";
            document.getElementById('mArea').innerText = Math.round(area) + " m¬≤";
            document.getElementById('mReq').innerText = requiredGuards;
            rangeInput.max = requiredGuards; rangeInput.min = 1; rangeInput.value = requiredGuards;
            updateModalCalc(requiredGuards);
            document.getElementById('guardModal').style.display = 'flex';
        };

        document.getElementById('btnConfirm').addEventListener('click', async () => {
            if (!selectedLandId) return;
            const count = parseInt(rangeInput.value);
            const cost = count * 10;
            if (totalPoints < cost) return alert("Insufficient points!");
            const updates = {};
            updates[`users/${currentUser}/creditPoints`] = totalPoints - cost;
            updates[`territories/${selectedLandId}/guarded`] = true;
            updates[`territories/${selectedLandId}/guardCount`] = count;
            updates[`territories/${selectedLandId}/guardExpiry`] = Date.now() + (7 * 24 * 60 * 60 * 1000);
            try { await update(ref(db), updates); alert("Guards Deployed!"); document.getElementById('guardModal').style.display = 'none'; } catch(e) { alert(e.message); }
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            if (!map && gameMode === 'outdoor') return alert("Map loading...");
            pathCoords = []; 
            document.getElementById('startBtn').style.display = 'none'; 
            
            const stopBtn = document.getElementById('stopBtn');
            stopBtn.style.display = 'block';
            stopBtn.innerText = "üö© Claim Territory (0 m¬≤)";
            stopBtn.classList.remove('ready'); 
            
            if (gameMode === 'outdoor') {
                activePolyline = new google.maps.Polyline({ path: [], strokeColor: "#FFFF00", strokeWeight: 6, map: map });
                watchId = navigator.geolocation.watchPosition(pos => {
                    const latLng = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                    pathCoords.push(latLng); 
                    activePolyline.getPath().push(new google.maps.LatLng(latLng.lat, latLng.lng));
                    map.panTo(latLng); 
                    updateUserMarker(latLng);

                    if (pathCoords.length > 2) {
                        const rawArea = google.maps.geometry.spherical.computeArea(activePolyline.getPath());
                        stopBtn.innerText = `üö© Claim Territory (${Math.round(rawArea)} m¬≤)`;
                        if (rawArea >= 1000) {
                            stopBtn.classList.add('ready'); 
                            stopBtn.innerText = `üèÜ CLAIM VICTORY (${Math.round(rawArea)} m¬≤)`;
                        } else {
                            stopBtn.classList.remove('ready');
                        }
                    }

                    checkGuardProximity(latLng);
                }, err => console.error(err), { enableHighAccuracy: true });
            } else {
                indoorDistance = 0; lastIndoorPos = null;
                document.getElementById('indDistLarge').innerText = "0"; document.getElementById('indAreaLarge').innerText = "0 m¬≤";
                watchId = navigator.geolocation.watchPosition(pos => {
                    const latLng = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                    if (lastIndoorPos) {
                        const from = new google.maps.LatLng(lastIndoorPos.lat, lastIndoorPos.lng);
                        const to = new google.maps.LatLng(latLng.lat, latLng.lng);
                        const dist = google.maps.geometry.spherical.computeDistanceBetween(from, to);
                        if (dist > 0.5 && dist < 50) { 
                            indoorDistance += dist;
                            const r = indoorDistance / (2 * Math.PI);
                            const area = Math.PI * r * r;
                            document.getElementById('indDistLarge').innerText = Math.round(indoorDistance);
                            document.getElementById('indAreaLarge').innerText = Math.round(area) + " m¬≤";
                        }
                    }
                    lastIndoorPos = latLng;
                }, err => console.error(err), { enableHighAccuracy: true });
            }
        });

        // CREDIT POINT LOGIC (1-2-4-6-5-8)
        function calculateNewPoints(streakDay) {
            if (streakDay === 1) return 1;
            if (streakDay === 2) return 2;
            if (streakDay === 3) return 4;
            if (streakDay === 4) return 6;
            if (streakDay >= 5 && streakDay <= 21) return 5;
            if (streakDay >= 22) return 8;
            return 1; 
        }

        document.getElementById('stopBtn').addEventListener('click', async () => {
            const btn = document.getElementById('stopBtn');
            const startBtn = document.getElementById('startBtn');

            // --- INDOOR LOGIC ---
            if (gameMode === 'indoor') {
                navigator.geolocation.clearWatch(watchId);
                const r = indoorDistance / (2 * Math.PI);
                const finalArea = Math.PI * r * r;
                
                if (finalArea < 5) {
                    alert("Walk more! Distance too short.");
                    startBtn.style.display = 'block'; btn.style.display = 'none'; return;
                }

                const updates = {};
                updates[`users/${currentUser}/bankedArea`] = (bankedArea || 0) + finalArea;

                // Credit Point Calculation (Indoor)
                let pointMsg = "";
                if (finalArea >= 1000) {
                    const now = new Date(); const todayStr = now.toDateString(); const lastDate = lastConquestDate ? new Date(lastConquestDate) : null;
                    let newStreak = 1; let pointsToAdd = 0;
                    if (!lastDate || lastDate.toDateString() !== todayStr) {
                         if (lastDate) { const oneDay = 24 * 60 * 60 * 1000; const diffDays = Math.round(Math.abs((new Date(now.getFullYear(), now.getMonth(), now.getDate()) - new Date(lastDate.getFullYear(), lastDate.getMonth(), lastDate.getDate())) / oneDay)); if (diffDays === 1) newStreak = currentStreak + 1; }
                        pointsToAdd = calculateNewPoints(newStreak);
                    } else { newStreak = currentStreak; pointMsg = "\n(Daily points already claimed)"; }
                    
                    if (pointsToAdd > 0) {
                        pointMsg = `\n+${pointsToAdd} Credit Points! (Streak: ${newStreak})`;
                        updates[`users/${currentUser}/creditPoints`] = totalPoints + pointsToAdd;
                    }
                    updates[`users/${currentUser}/streak`] = newStreak;
                    updates[`users/${currentUser}/lastActiveDate`] = Date.now();
                }

                try { await update(ref(db), updates); alert(`Training Complete!\nBanked: ${Math.round(finalArea)} m¬≤.${pointMsg}`); } 
                catch(e) { alert("Error saving: " + e.message); }
                startBtn.style.display = 'block'; btn.style.display = 'none';
                return;
            }

            // --- OUTDOOR LOGIC ---
            if (pathCoords.length < 3) { 
                alert("Path too short."); 
                navigator.geolocation.clearWatch(watchId);
                activePolyline.setMap(null);
                startBtn.style.display = 'block'; btn.style.display = 'none';
                return;
            }

            navigator.geolocation.clearWatch(watchId);
            btn.innerText = "Calculations..."; 
            btn.disabled = true;

            try {
                const turfCoords = pathCoords.map(p => [p.lng, p.lat]);
                turfCoords.push([pathCoords[0].lng, pathCoords[0].lat]); 
                const newPoly = turf.polygon([turfCoords]);
                const rawArea = google.maps.geometry.spherical.computeArea(activePolyline.getPath());
                let finalMyArea = rawArea;

                const snapshot = await get(ref(db, 'territories'));
                const territories = snapshot.val() || {};
                const updates = {};
                let stolenText = "";
                let guardBlocked = false;

                for (const [key, t] of Object.entries(territories)) {
                    if(!t.coords || t.owner === currentUser) continue;
                    const tCoords = t.coords.map(c => [c.lng, c.lat]);
                    tCoords.push([t.coords[0].lng, t.coords[0].lat]);
                    const existingPoly = turf.polygon([tCoords]);
                    const intersection = turf.intersect(newPoly, existingPoly);
                    
                    if (intersection) {
                        const overlapArea = turf.area(intersection);
                        if (overlapArea > 0) {
                            let isProtected = false;
                            if (t.guarded) {
                                if (t.guardExpiry && t.guardExpiry > Date.now()) { isProtected = true; } 
                                else { updates[`territories/${key}/guarded`] = null; }
                            }
                            if (isProtected) { guardBlocked = true; finalMyArea -= overlapArea; continue; }
                            
                            const isAlly = myClanMembers[t.owner] ? true : false;
                            let currentEnemyArea = t.areaSize || 0;
                            const intersectCoords = intersection.geometry.coordinates[0].map(c => ({ lat: c[1], lng: c[0] }));
                            new google.maps.Polygon({ paths: intersectCoords, fillColor: "#ff0000", fillOpacity: 0.6, strokeColor: "#ff0000", strokeWeight: 2, map: map });

                            if (isAlly) {
                                let newEnemyArea = Math.max(0, currentEnemyArea - (overlapArea / 2));
                                updates[`territories/${key}/areaSize`] = newEnemyArea;
                                finalMyArea -= (overlapArea / 2);
                                stolenText += `\nShared ${Math.round(overlapArea)}m¬≤ with ally ${t.owner}`;
                            } else {
                                let newEnemyArea = Math.max(0, currentEnemyArea - overlapArea);
                                updates[`territories/${key}/areaSize`] = newEnemyArea;
                                stolenText += `\nSeized ${Math.round(overlapArea)}m¬≤ from ${t.owner}`;
                                const timestamp = Date.now();
                                const battleLog = { attacker: currentUser, defender: t.owner, area: overlapArea, coords: intersectCoords, timestamp: timestamp, locName: "Unknown Wilderness" };
                                updates[`userBattleLogs/${currentUser}/attacks/${timestamp}`] = battleLog;
                                updates[`userBattleLogs/${t.owner}/defense/${timestamp}`] = battleLog;
                            }
                        }
                    }
                }

                if (guardBlocked) alert("‚ö†Ô∏è GUARD ENCOUNTERED! ‚ö†Ô∏è\nProtected areas were not captured.");

                if (finalMyArea > 10) {
                    const newKey = push(ref(db, 'territories')).key;
                    updates[`territories/${newKey}`] = { owner: currentUser, coords: pathCoords, areaSize: finalMyArea, timestamp: Date.now(), source: 'Battle' };

                    if(myClan) {
                        const clanSnap = await get(ref(db, `clans/${myClan}`));
                        if(clanSnap.val() && clanSnap.val().activeWar) {
                             const warId = clanSnap.val().activeWar;
                             await runTransaction(ref(db, `clanWars/${warId}`), (war) => {
                                if (war) {
                                    if (war.challenger === myClan) war.challengerScore = (war.challengerScore || 0) + finalMyArea;
                                    else if (war.defender === myClan) war.defenderScore = (war.defenderScore || 0) + finalMyArea;
                                }
                                return war;
                             });
                        }
                    }

                    // Credit Point Logic (Outdoor)
                    let pointMsg = "";
                    if (finalMyArea >= 1000) {
                        const now = new Date();
                        const todayStr = now.toDateString();
                        const lastDate = lastConquestDate ? new Date(lastConquestDate) : null;
                        let newStreak = 1;
                        let pointsToAdd = 0;
                        if (!lastDate || lastDate.toDateString() !== todayStr) {
                             if (lastDate) {
                                const oneDay = 24 * 60 * 60 * 1000;
                                const diffDays = Math.round(Math.abs((new Date(now.getFullYear(), now.getMonth(), now.getDate()) - new Date(lastDate.getFullYear(), lastDate.getMonth(), lastDate.getDate())) / oneDay));
                                if (diffDays === 1) newStreak = currentStreak + 1;
                            }
                            pointsToAdd = calculateNewPoints(newStreak);
                        } else { newStreak = currentStreak; pointMsg = "\n(Daily points already claimed)"; }
                        
                        if (pointsToAdd > 0) {
                            pointMsg = `\n+${pointsToAdd} Credit Points! (Streak: ${newStreak})`;
                            updates[`users/${currentUser}/creditPoints`] = totalPoints + pointsToAdd;
                        }
                        updates[`users/${currentUser}/streak`] = newStreak;
                        updates[`users/${currentUser}/lastActiveDate`] = Date.now();
                    }

                    await update(ref(db), updates);
                    alert(`Conquest Complete!\nClaimed: ${Math.round(finalMyArea)} m¬≤${stolenText}${pointMsg}`);
                } else { alert("Area too small or blocked by guards."); }

            } catch(e) { 
                console.error(e); 
                alert("Error during calculation: " + e.message); 
            } finally {
                activePolyline.setMap(null);
                startBtn.style.display = 'block'; 
                btn.style.display = 'none';
                btn.disabled = false;
                btn.innerText = "üö© Claim Territory";
            }
        });

        function loadTerritories() {
            onValue(ref(db, 'territories'), (snapshot) => {
                const data = snapshot.val();
                visualPolygons.forEach(obj => { obj.poly.setMap(null); if(obj.marker) obj.marker.setMap(null); });
                visualPolygons = [];
                allPolygons = []; 
                loadStatsAndRank(data || {});

                if (data) Object.entries(data).forEach(([key, t]) => { 
                    const tCoords = t.coords.map(c => [c.lng, c.lat]);
                    tCoords.push([t.coords[0].lng, t.coords[0].lat]);
                    const turfPoly = turf.polygon([tCoords]);
                    allPolygons.push({ id: key, data: t, polygon: turfPoly });

                    const isMine = t.owner === currentUser;
                    const isAlly = myClan && myClanMembers[t.owner];
                    
                    if (isMine || isAlly) {
                        let isActiveGuard = t.guarded && (!t.guardExpiry || t.guardExpiry > Date.now());
                        let strokeC = isActiveGuard ? '#FFD700' : '#222';
                        let strokeW = isActiveGuard ? 3 : 1;
                        let fillC = isMine ? '#00e676' : '#C5A059'; 
                        
                        const poly = new google.maps.Polygon({ 
                            paths: t.coords, fillColor: fillC, fillOpacity: 0.25, strokeColor: strokeC, strokeWeight: strokeW, map: map, clickable: true, zIndex: isActiveGuard ? 10 : 1
                        });

                        poly.addListener('click', () => {
                            if (isActiveGuard) {
                                const daysLeft = Math.ceil((t.guardExpiry - Date.now())/(1000*60*60*24));
                                alert(`Protected.\nExpires in ${daysLeft} days.`);
                            } else {
                                window.openDeploymentModal(key, t.areaSize || 0, !isMine);
                            }
                        });
                        
                        let marker = null;
                        if(isActiveGuard) {
                            const bounds = new google.maps.LatLngBounds();
                            t.coords.forEach(c => bounds.extend(c));
                            marker = new google.maps.Marker({ position: bounds.getCenter(), map: map, label: { text: "üõ°Ô∏è", fontSize: "16px" }, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 0 } });
                        }
                        visualPolygons.push({ poly, marker });
                    }
                });
            });
        }

        // --- TRIGGER LOAD ---
        loadGoogleMaps();
    </script>
</body>
</html>
